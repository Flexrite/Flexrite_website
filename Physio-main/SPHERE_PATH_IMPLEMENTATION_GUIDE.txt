🌐 GLOBAL SPHERE PATH IMPLEMENTATION GUIDE
===============================================

This guide provides step-by-step instructions to implement custom path animations for the 3D sphere across all sections of your website.

📋 OVERVIEW
-----------
Transform your sphere from a hero-section component to a global element that follows custom paths through all website sections with smooth animations.

🔧 STEP 1: PROJECT STRUCTURE SETUP
-----------------------------------
Create the following file structure:

src/
├── components/
│   ├── ThreeDSphere.tsx (existing - already created)
│   ├── GlobalSphereController.tsx (new)
│   ├── PathShapes.tsx (new)
│   └── ui/
│       └── PathBuilder.tsx (optional - for visual path creation)
├── app/
│   └── layout.tsx (modify existing)
└── styles/
    └── globals.css (modify existing)

🚀 STEP 2: MOVE SPHERE TO GLOBAL LEVEL
---------------------------------------

2.1 REMOVE SPHERE FROM HERO COMPONENT:
- Open: client/components/Hero.tsx
- Remove the sphere container div (lines ~279-290)
- Keep only the hero text content

2.2 ADD SPHERE TO LAYOUT:
- Open: app/layout.tsx (or your main layout file)
- Add the global sphere container:

```tsx
import ThreeDSphere from '../client/components/ThreeDSphere';

export default function Layout({ children }) {
  return (
    <html lang="en">
      <body>
        {/* Global Sphere - Fixed positioned */}
        <div 
          id="global-sphere"
          className="fixed z-[9999] pointer-events-none" 
          style={{
            left: '50%',
            top: '50%',
            transform: 'translate(-50%, -50%)'
          }}
        >
          <ThreeDSphere />
        </div>
        
        {/* Page Content */}
        <main className="relative z-[1]">
          {children}
        </main>
      </body>
    </html>
  );
}
```

🎯 STEP 3: CREATE PATH SHAPES LIBRARY
--------------------------------------

3.1 CREATE PathShapes.tsx:

```tsx
// components/PathShapes.tsx
export const PathShapes = {
  // Sine wave path
  sineWave: (progress: number, amplitude: number = 200, frequency: number = 3) => {
    return {
      x: 50 + Math.sin(progress * Math.PI * frequency) * (amplitude / window.innerWidth * 100),
      y: 10 + progress * 80
    };
  },

  // Spiral path
  spiral: (progress: number, radius: number = 300, turns: number = 2) => {
    const angle = progress * Math.PI * 2 * turns;
    const currentRadius = radius * (1 - progress * 0.3);
    
    return {
      x: 50 + (Math.cos(angle) * currentRadius) / window.innerWidth * 100,
      y: 20 + progress * 60 + (Math.sin(angle) * currentRadius) / window.innerHeight * 100
    };
  },

  // Figure-8 path
  figure8: (progress: number, width: number = 400, height: number = 200) => {
    const t = progress * Math.PI * 2;
    
    return {
      x: 50 + (Math.sin(t) * width) / window.innerWidth * 100,
      y: 50 + (Math.sin(t) * Math.cos(t) * height) / window.innerHeight * 100
    };
  },

  // Zigzag path
  zigzag: (progress: number, amplitude: number = 300, segments: number = 5) => {
    const segmentProgress = (progress * segments) % 1;
    const segmentIndex = Math.floor(progress * segments);
    const direction = segmentIndex % 2 === 0 ? 1 : -1;
    
    return {
      x: 50 + direction * (segmentProgress * 2 - 1) * (amplitude / window.innerWidth * 100),
      y: progress * 80 + 10
    };
  },

  // Custom section-based path
  sectionBased: (progress: number) => {
    const sections = [
      { start: 0, end: 0.25, pos: { x: 50, y: 60 } }, // Hero
      { start: 0.25, end: 0.5, pos: { x: 20, y: 50 } }, // About
      { start: 0.5, end: 0.75, pos: { x: 80, y: 40 } }, // Services
      { start: 0.75, end: 1, pos: { x: 50, y: 30 } }    // Contact
    ];

    const currentSection = sections.find(s => progress >= s.start && progress < s.end);
    if (!currentSection) return sections[sections.length - 1].pos;

    const sectionProgress = (progress - currentSection.start) / (currentSection.end - currentSection.start);
    const nextSection = sections[sections.indexOf(currentSection) + 1];
    
    if (!nextSection) return currentSection.pos;

    return {
      x: currentSection.pos.x + (nextSection.pos.x - currentSection.pos.x) * sectionProgress,
      y: currentSection.pos.y + (nextSection.pos.y - currentSection.pos.y) * sectionProgress
    };
  }
};
```

🎮 STEP 4: CREATE GLOBAL CONTROLLER
------------------------------------

4.1 CREATE GlobalSphereController.tsx:

```tsx
// components/GlobalSphereController.tsx
'use client';
import { useEffect } from 'react';
import { PathShapes } from './PathShapes';

export default function GlobalSphereController() {
  useEffect(() => {
    const sphere = document.getElementById('global-sphere');
    if (!sphere) return;

    const handleScroll = () => {
      const scrollY = window.scrollY;
      const maxScroll = document.body.scrollHeight - window.innerHeight;
      const progress = Math.min(scrollY / maxScroll, 1);
      
      // Choose your path (change this to switch paths)
      const position = PathShapes.spiral(progress, 300, 3);
      // const position = PathShapes.sineWave(progress, 200, 2);
      // const position = PathShapes.figure8(progress, 400, 200);
      // const position = PathShapes.sectionBased(progress);
      
      sphere.style.left = `${position.x}%`;
      sphere.style.top = `${position.y}%`;
      sphere.style.transform = `
        translate(-50%, -50%) 
        rotateZ(${progress * 1080}deg)
      `;
      sphere.style.transition = 'all 0.1s ease-out';
    };

    window.addEventListener('scroll', handleScroll);
    handleScroll(); // Initial position

    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  return null;
}
```

4.2 ADD CONTROLLER TO LAYOUT:

```tsx
import GlobalSphereController from '../components/GlobalSphereController';

export default function Layout({ children }) {
  return (
    <html lang="en">
      <body>
        <GlobalSphereController />
        <div id="global-sphere" className="fixed z-[9999] pointer-events-none">
          <ThreeDSphere />
        </div>
        <main className="relative z-[1]">
          {children}
        </main>
      </body>
    </html>
  );
}
```

🎨 STEP 5: UPDATE CSS FOR GLOBAL SPHERE
----------------------------------------

5.1 ADD TO globals.css:

```css
/* Global Sphere Styles */
#global-sphere {
  position: fixed !important;
  z-index: 9999 !important;
  pointer-events: none !important;
  transition: all 0.1s ease-out;
}

/* Ensure sphere appears above everything */
.sphere-container {
  isolation: isolate;
}

/* Section content should have lower z-index */
.section-content {
  position: relative;
  z-index: 100;
}

/* Background elements */
.section-background {
  position: relative;
  z-index: 1;
}
```

📐 STEP 6: ADJUST SECTION LAYOUTS
----------------------------------

6.1 LEAVE SPACE FOR SPHERE:
- Add margins/padding to sections where sphere will be positioned
- Use CSS Grid or Flexbox to create responsive layouts around sphere path

6.2 EXAMPLE SECTION MODIFICATION:

```tsx
<section className="relative min-h-screen py-16">
  <div className="container mx-auto px-4">
    {/* Leave space for sphere on the left */}
    <div className="ml-20 lg:ml-40">
      <h2>Section Title</h2>
      <p>Section content...</p>
    </div>
  </div>
</section>
```

🔧 STEP 7: ADVANCED CUSTOMIZATION
----------------------------------

7.1 ADD EASING FUNCTIONS:

```tsx
const easing = {
  easeInOut: (t: number) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
  easeIn: (t: number) => t * t * t,
  easeOut: (t: number) => (--t) * t * t + 1,
  bounce: (t: number) => {
    if (t < 1/2.75) return 7.5625 * t * t;
    if (t < 2/2.75) return 7.5625 * (t -= 1.5/2.75) * t + 0.75;
    if (t < 2.5/2.75) return 7.5625 * (t -= 2.25/2.75) * t + 0.9375;
    return 7.5625 * (t -= 2.625/2.75) * t + 0.984375;
  }
};

// Usage:
const easedProgress = easing.bounce(progress);
const position = PathShapes.spiral(easedProgress, 300, 2);
```

7.2 ADD SPEED VARIATIONS:

```tsx
const variableSpeed = (progress: number, sections: number) => {
  const sectionIndex = Math.floor(progress * sections);
  const speeds = [0.5, 1.5, 0.8, 2.0]; // Different speeds per section
  const speed = speeds[sectionIndex] || 1;
  return progress * speed;
};
```

🧪 STEP 8: TESTING AND DEBUGGING
---------------------------------

8.1 ADD DEBUG OVERLAY:

```tsx
// Add to GlobalSphereController for debugging
const [debugInfo, setDebugInfo] = useState({ progress: 0, x: 0, y: 0 });

// Update in handleScroll:
setDebugInfo({ progress, x: position.x, y: position.y });

// Render debug info:
return (
  <div className="fixed top-4 left-4 bg-black/50 text-white p-2 rounded z-[10000]">
    <div>Progress: {debugInfo.progress.toFixed(3)}</div>
    <div>X: {debugInfo.x.toFixed(1)}%</div>
    <div>Y: {debugInfo.y.toFixed(1)}%</div>
  </div>
);
```

8.2 VISUAL PATH PREVIEW:

```tsx
// Add path preview line (development only)
const showPathPreview = () => {
  const points = [];
  for (let i = 0; i <= 100; i++) {
    const progress = i / 100;
    const pos = PathShapes.spiral(progress, 300, 3);
    points.push(`${pos.x}% ${pos.y}%`);
  }
  
  const pathElement = document.createElement('div');
  pathElement.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 9998;
    background: ${points.map((point, i) => 
      `radial-gradient(circle at ${point}, red 2px, transparent 2px)`
    ).join(',')};
  `;
  document.body.appendChild(pathElement);
};
```

🚀 STEP 9: DEPLOYMENT CHECKLIST
--------------------------------

☐ Remove all debug code and console.logs
☐ Test on different screen sizes (mobile, tablet, desktop)
☐ Verify sphere doesn't block important UI elements
☐ Test scroll performance (should be smooth)
☐ Ensure sphere path works with lazy-loaded content
☐ Test with different scroll speeds (fast/slow scrolling)
☐ Verify z-index doesn't conflict with modals/dropdowns
☐ Test accessibility (sphere shouldn't interfere with screen readers)

📝 STEP 10: CUSTOMIZATION OPTIONS
----------------------------------

To customize the sphere path:

1. CHANGE PATH TYPE:
   - Edit PathShapes call in GlobalSphereController.tsx
   - Switch between: spiral, sineWave, figure8, zigzag, sectionBased

2. ADJUST PATH PARAMETERS:
   - amplitude: How wide the path curves
   - frequency: How many curves/waves
   - radius: Size of circular paths
   - turns: Number of rotations for spiral

3. MODIFY TIMING:
   - Change scroll range (scrollStart/scrollEnd)
   - Add easing functions
   - Adjust rotation speed (multiply progress by different values)

4. ADD SECTION-SPECIFIC BEHAVIOR:
   - Define waypoints at specific scroll positions
   - Add scale/rotation changes at section boundaries
   - Implement pause points where sphere stops briefly

🎯 QUICK START COMMANDS
-----------------------

1. Copy PathShapes.tsx to your components folder
2. Copy GlobalSphereController.tsx to your components folder
3. Move sphere from Hero.tsx to layout.tsx
4. Add GlobalSphereController to your layout
5. Choose a path type in the controller
6. Test and adjust parameters

🔄 PATH SWITCHING EXAMPLES
--------------------------

// For gentle movement:
const position = PathShapes.sineWave(progress, 150, 1);

// For dramatic spirals:
const position = PathShapes.spiral(progress, 400, 4);

// For section-to-section jumps:
const position = PathShapes.sectionBased(progress);

// For playful bouncing:
const easedProgress = easing.bounce(progress);
const position = PathShapes.zigzag(easedProgress, 300, 6);

===============================================
🎉 IMPLEMENTATION COMPLETE!

Your sphere will now follow custom paths across all sections of your website, creating an engaging and dynamic user experience.

For support or advanced customizations, refer to the PathShapes.tsx file and experiment with different mathematical functions to create unique movement patterns.